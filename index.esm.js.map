{"version":3,"file":"index.esm.js","sources":["src/constant.ts","src/cursorConfig.ts","src/classes.ts","src/penTool.ts"],"sourcesContent":["const CONST = {\r\n    OBJECT_TYPE: {\r\n        PEN_AUX: \"penAux\",\r\n        CIRCLE: \"circle\",\r\n        LINE: \"line\",\r\n        PATH: \"path\"\r\n    },\r\n    POINT_TYPE: {\r\n        STRAIGHT: \"straight\",\r\n        MIRRORED: \"mirrored\",\r\n        DISJOINTED: \"disjointed\"\r\n    },\r\n    CONTROL_TYPE: {\r\n        LEFT: \"handleA\",\r\n        RIGHT: \"handleB\",\r\n        MAIN: \"main\"\r\n    },\r\n    PATH_STATE: {\r\n        NEW: \"new\"\r\n    },\r\n    CURSOR_TYPE: {\r\n        ADD: 'add',\r\n        NORMAL: 'normal',\r\n        MOVE: 'move',\r\n        CLOSE: 'close',\r\n        DEFAULT: 'default'\r\n    }\r\n}\r\nexport default CONST;","/**\r\n * author Siwei\r\n * 鼠标手势、鼠标位置\r\n */\r\nconst cursorConfig = {\r\n  normal: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAAXNSR0IArs4c6QAABIdJREFUSA3tVWsspFcY/uaW0dgiOqQimQ3iPmkQtyIShlWEbK0uUlGXdkkbTRBtGlIlQmls2B/qkobBH2JIMFHpBE0YGWwRxqWWBl1WMmu2SnXMfDN9zrQz2c5mN4bd/upJTs533vNevue9UnK5/Obk5GTb8fGxB/VfrIGBgZH4+Hh9dXW1cmxsbHR7e/vGq7TLEIvFEq1WK9RoNFqFQvHn7u6uVUpKypK3t3cPdjuDwdC+zB9gEmVWVlbHg4ODzOTk5J8KCgokGxsbzqWlpfe6urruz8/Pf63X621emlGCsKmpaWtiYuKH7OzsJ+vr66kwwENs77W1tSngbrqhoeHB1NSUCPTrVzXMhsv0REloaGje3Nzcj0D0paen5/chISGfwgCXnECc2tjY+N7w8PANqVQ67+bmVu3i4iK/lHGSNAQhEV5YWCiDW9UymayLGMNmG5VubW3dGhkZkWZlZT3u7+9fNdItPU0KiaCfn19NcXFxIpTfnpmZEep0Oo1EIvk5KCjoY0dHRzFYxENDQ8PIZIGlhoz8hqQxXoh7z8/POUggtqur60N3d3cFPOA3Pj4+CLS2hA8njYxmPI3eKH+R04iQQZiVSmVIUVGRd0lJyUB4ePhtQltZWfm8rKys2sPDoxjXChaLRavVavKjHGyLS+ZfCE9PT/knJyfWNjY2poTw9fX9zsvLS3l0dOQKAxSTydShbo0GCcmixTRmKZHi8/kzQPIIKwkuIwio5eXlPGyera3tQ3InCOH2Sxs0uBRGiS4K56/T09OjdXV17+/s7Mz29PQc19bWCtLS0jYDAwO/ITwE4T8uNYaDkC+8DC4FGpIE1kQqLCwsr7y8/C6bzdaiob+RmZkpi4mJeRc/85i8wyANl7IODg7eRl0OtbS0KJaWlj4kbxdZbCcnJ1VzczOfw+Hcn52dlUKoIjg4+AucZD+zuFwuBbTXampqRCqVyprH47HQhZoWFxdZKKvWZwTMCEx0ko/Quirs7Oz+qKqqyq+vr5+Hgm4g5pvxUug4Cfv7++90dnZyfXx8Xj88PGShZCgkFhcyn0GGZy5jfv87eKCCmbW2tnZndXX1g97e3rdQg09iY2PlUPwViv4XxLa5vb092d7e/jW0PnZlZSUF1xr0ZWRkUGgGNMqpPyoqKt3cyNN3U+ARIxoP35IN4VQY/kQkEkX7+/sLYYTC5LBOTExk9vX1UUgmkw60Qgpu1W1ubuppmlabHp7zYUJo/g7EtkA1jPiGCQQC5tnZGaO1tZV4wsCK2FM5OTkUXEpHRkbuC4XCxoCAgLvmeszvzzWIRi1DUw9OSEhgdXd3U3t7eybZ9PR0Cs1Bh4GtKSwsHI+Ojs6Fhx6ZGCz9AIrr+fn556hBvYODg2kje/UYU/q4uDgayB/AYK6luk0xNBP8zdnZWYlafBN0BmqPwliiMD10GMxq1KkkIiLiDlCpzOQuf8VMFCUlJWlQMgZUKH66o6MDibx26/JaXyAJt15D7JbReXS5ubm/4wc6QTN0oxeIXe0JoykOyTOKgRxzNU3/S79CD/wF1bAnj93p/FEAAAAASUVORK5CYII=\",\r\n  add: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAAXNSR0IArs4c6QAABUlJREFUSA29VnkspVcU/96ijxrrvFKVUPveILYiGoxJkUqrOihRW6cyTRpLtYpUiaU0JswfxpImtkSIJbFEZayJJZYpYqfMoMOQZxljGct7+ruv/V4673UmGNOb3Nx3zz3n/L7fueec+6j+/v6POzs7C3d2dvSp/2PU1tY2uru7n6ampvJaWlqaFxYWrr9OXEZNTU3TycmJ6/Hx8cnExMSzpaUlaW9v71EjI6NyzCIGg3FymR/AJM6kpaV36urqmF5eXr9HREQ0zczMqMfGxt4pLS29PzQ09PPp6an8pYEShrm5ufMdHR33goODt6enp30AwMXd3iksLJxAuPnZ2dl/dHd3l0Cu+arAbITslDixs7MLGxwc7AKjHw0MDH6ztbX9BgAcsoKxT05OzmcNDQ3XW1tbh3R0dFK1tLT6LwROkoYwJMbDw8MJCOthb29vKQHDZNNO5+fnP21sbGwNCgraqK6unqTl511FDomhubl5enR0tCec3+jr63MVCATHTU1Ns9bW1rdUVFRqoFJTX1/fgEw2PS8QrS9MGnpDwnt0dCSFBGJra2s/0tPTm0AEzNvb2+vAVoHoYeUjoxn/Zk/bn2WlGTKIMo/Hs42KijKKiYmpdXBwuEFk4+Pj3yckJKTq6+tHY5vEYrH4h4eH5EOlMM9dMs8x3Nvb09jd3ZWVl5cXJYSJicmvhoaGvM3NTW0AUEwmU4C6pQGJ6FyDSWcpsdLQ0OgDk8cYHyFkhAE1NjYWhslVUFB4RPaEIcJ+YUBhSAFKfFFY/+zp6WnOzMwMWFxcHCgvL9/JyMgw9fX1nbOysvqF6BCG/4SUvg4iPvMQhhRsSBLIEit7e/uwxMTE22w2+wQN/WpgYGDvtWvXPsHHbJBzAPIRUtbq6ur7qMv6/Pz8idHR0XBydpbBVlNT28rLy9OQkpK6PzAw0AqjJBsbmx+wkikxOBwOBbZX0tPTS7a2tmS5XC4LXSh3ZGSEhbIqkDAQEzDRSb5E60pSVFTcT0lJ+SorK2sIDsrAWENMl0LH8VhZWfmwuLiYY2xsLLe2tsZCyVBILA5svoMNV9xGfP/35UEKZdbU1NTNycnJLyorK99DDW67ubn1w/FPKPoHuNu8oqIiL2VlZRm0PnZycjKF0Ar9+fv7U2gGfJRTtbOzsx98kYRj4RqeiQOKLh6HfBzeJRPGPgD+uqSkxMXCwsIVIBReDllPT09mVVUVhWQS+UErpBBWwdzc3Cmfzz8kB21tbb37+/tXAawDv8JeTRuIGNICeoWyAlg14H7tTU1NmQcHB4yCggISCaEK7p4KCQmhEFK+k5PTiqura46lpeVtcohX5uH29vZbeOIUAPhccxAxpIHoFT20GU3dxsPDg1VWVkYtLy/TR5Sfnx+F5iDo6uo6joyMbHdxcQmF48cihZf8EJaF+DlYaCLlreCIhWwUgeFJotDmqNnZWYG6uvqDtLS0W2DmAfsnsFGlJ/bCyKF01PEP4h0y0UyEZfcihk/gkIdafJsYo/YoPEsUXg8BHuZD1GmTo6PjTbDaQqK9W1FR0Y9u9CaOpchEXTJJQq2vrz+EvXCYmZnxcM8f/CcgHG3jTbyHLvN5XFwcG+2MwlsoCAgImA0PD0/Efx3yVAmHqqrqFs6fampqHtOyjY0NZXSjN3R1dUVhlpGR2ZeTk+PROhIrwnMFdzeGziMIDQ19ig8ohkwYFgllMQFJGtTzHvQlCEkIaFuw3MXT9G18fHwkGGXjbwXpQq88XghIPKMcWrCQeWnjpYAXRSElg0Qj9ScQ9/FaAJWUlILRKLi4FgnAvwBe6YatAEV1yQAAAABJRU5ErkJggg==\",\r\n  close: \"data:image/png;base64,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\",\r\n  move: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAAXNSR0IArs4c6QAAAstJREFUSA3Nld9rklEYx+cMBX/QTaIIKjkYbqibiOAfINJNNxt6E8KIjIVEUBRBRHTRv2Ajhxde7c4LyboJvIguYhqDyS4G2RxqTRvOWkaSp+/zsgOv+r7h/BEdODzvec7zfT7vec9zzjvDGHN1Op3gzL9qAF7LZrOHjUbjGZ5np84FJOL3+38GAoGjg4ODlxhfmioUgDWfz9cGhBmNxl/5fP49fP6pQZH8utfr/UFA6kqlkiUSid1Wq3VvKlAAb3g8nlMO5DYcDpdrtdoW5vUTBSPhzaWlpe8cJLZ2u/10b2/vLWKcE4Mi2S2n0/lNDBI/q9Vqlk6nP7Tb7bWJQAGMLS4utsQQqedYLLZfr9dfIF49FhgJbjscjhMpSL/P7XYfl0qlN9BcHhkK8Z35+flmf3K5sV6v/53L5ejoXB0JCuHdubm5YzkA9ysUCmYwGJjL5WLBYJAVi8UvuBLvnxd6AYLZbrdLZ7CnRaPRLs5nU6PRnOh0OupNQA9RRPtWq3XXZrN9hOATF+HFtXi+gv4acXTMpBsCH0DcwKxw8Mmur6934/H4c2nFoBc5LpbL5e2VlRVGlsaDUWceTD60WCx1DAVgJBJhGxsbW7KCvgkOW1hYEPRk/wqF4JHZbD4iIL3h5ubmq76cskOCVavVbdxUjM4r5SBLY/LT/IAYzscmk+kzFUIymXw3ECDj4DBYoVUqFQFIljdJKCaf4N78mkqldpBbIZO/xw2NsGfLy8s8N5MC0koHPi8UTzOZzE4oFFL2ZJUZIF5LSWivVCqVACJYoVAQVkiWxtTp84r2lKoYH50xI/rQf3rErtJek3TYTvGkI965G4TCCnH/jrbCcxMhAFTYQ9oj3obew1GApCHoWRUKTCmgZJWOChRDaaVUQPQeZKl6Jw7jL0orpaqlPSWgqCoHDz0XjWs5dKi7dFwY1wOqRV8ly33/hf0D+qqSk3G9oaMAAAAASUVORK5CYII=\"\r\n}\r\n\r\nexport default cursorConfig;\r\n","import CONST from './constant'\r\nimport { IPoint, IController } from './interface'\r\n\r\nclass PenObject {\r\n    /**\r\n     * Identify the object as an auxiliary point or line of the path\r\n     * Since js does not support static attributes, \r\n     * this attribute will be used as read-only. Please do not modify during use\r\n     */\r\n    // static penType: string = CONST.OBJECT_TYPE.PEN_AUX;\r\n    penType: string = CONST.OBJECT_TYPE.PEN_AUX;\r\n\r\n    /**\r\n     * The type of drawing object. \r\n     * Since js does not support static attributes, \r\n     * this attribute will be used as read-only. Please do not modify during use\r\n     */\r\n    // static type: string = CONST.OBJECT_TYPE.CIRCLE;\r\n    type: string;\r\n\r\n    /**\r\n     * property of the Canvas 2D API specifies the color, gradient, or pattern \r\n     * to use for the strokes (outlines) around shapes.\r\n     */\r\n    stroke: String | CanvasGradient | CanvasPattern = '#ff56b1';\r\n\r\n    /**\r\n     * property of the Canvas 2D API specifies the color, gradient, or pattern \r\n     * to use inside shapes.\r\n     */\r\n    fill: String | CanvasGradient | CanvasPattern = '#006cff';\r\n\r\n    /**\r\n     * property of the Canvas 2D API sets the thickness of lines.\r\n     */\r\n    lineWidth: number = 1;\r\n\r\n    constructor(options: any = {}) {\r\n        this.penType = CONST.OBJECT_TYPE.PEN_AUX;\r\n        this.stroke = options.stroke || '#ff56b1';\r\n        this.fill = options.fill || '#006cff';\r\n        this.lineWidth = options.lineWidth || 1;\r\n    }\r\n}\r\n\r\n/**\r\n * aux Circle of penTool\r\n */\r\nclass PenCircle extends PenObject {\r\n    /**\r\n     * The x coordinate of the center of the circle\r\n     */\r\n    x: number;\r\n\r\n    /**\r\n     * The y coordinate of the center of the circle\r\n     */\r\n    y: number;\r\n\r\n    /**\r\n     * Radius of Circle\r\n     */\r\n    radius: number = 3;\r\n\r\n    /**\r\n     * name of circle when circle as a handler\r\n     */\r\n    handleName?: string;\r\n\r\n    /**\r\n     * The index of the associated key point when circle as a handler\r\n     */\r\n    keyPointIndex: number;\r\n\r\n    /**\r\n     * property of the Canvas 2D API specifies the color, gradient, or pattern \r\n     * to use for the strokes (outlines) around shapes.\r\n     */\r\n    stroke: String | CanvasGradient | CanvasPattern = '#006cff';\r\n\r\n    /**\r\n     * property of the Canvas 2D API specifies the color, gradient, or pattern \r\n     * to use inside shapes.\r\n     */\r\n    fill: String | CanvasGradient | CanvasPattern = '#fff';\r\n\r\n    constructor(options: any = {}) {\r\n        super(options);\r\n        this.x = options.x;\r\n        this.y = options.y;\r\n        this.radius = options.radius || 3;\r\n        this.keyPointIndex = options.keyPointIndex;\r\n        this.handleName = options.handleName;\r\n        this.fill = options.fill || '#fff';\r\n        this.stroke = options.stroke || '#006cff';\r\n        this.type = CONST.OBJECT_TYPE.CIRCLE;\r\n    }\r\n}\r\n\r\n/**\r\n * aux Line of penTool\r\n */\r\nclass PenLine extends PenObject {\r\n    /**\r\n     * The x coordinate of an endpoint of the line segment\r\n     */\r\n    x1: number;\r\n\r\n    /**\r\n     * The y coordinate of an endpoint of the line segment\r\n     */\r\n    y1: number;\r\n    \r\n    /**\r\n     * The x coordinate of another endpoint of the line segment\r\n     */\r\n    x2: number;\r\n    \r\n    /**\r\n     * The y coordinate of another endpoint of the line segment\r\n     */\r\n    y2: number;\r\n\r\n    constructor(options: any = {}) {\r\n        super(options);\r\n        this.x1 = options.x1;\r\n        this.y1 = options.y1;\r\n        this.x2 = options.x2;\r\n        this.y2 = options.y2;\r\n        this.type = CONST.OBJECT_TYPE.LINE;\r\n    }\r\n}\r\n\r\n/**\r\n * declare path keyPoint Class\r\n */\r\nclass KeyPoint {\r\n    /**\r\n     * svg path key letter. 'M' means moveTo, 'C' means curveTo\r\n     */\r\n    type: string;\r\n\r\n    /**\r\n     * the mousedown keyPoint\r\n     */\r\n    point: IPoint;\r\n\r\n    /**\r\n     * Indicate the relationship between current keyPoint and previous keyPoint\r\n     * 'straight' means drawing a Line from previous to current \r\n     * 'mirrored' means drawing a curve. Cause there will be 2 handlers which are mirror symmetry centered on current keyPoint and in a straight line\r\n     * 'disjointed' means the curve's handlers are not in a straight line\r\n     * @default 'straight'\r\n     */\r\n    pointType: string = CONST.POINT_TYPE.STRAIGHT;\r\n\r\n    /**\r\n     * Coordinates related to the current keyPoint\r\n     * When keyPoint's type is 'M', the array length is 2, the coordinates of the current point are saved\r\n     * When keyPoint's type is 'C', the array length is 6. likes [prevLeft, prevTop, curLeft, curTop, curLeft, curTop]\r\n     */\r\n    relationPoints: number[];\r\n\r\n    /**\r\n     * Index of keyPointData array\r\n     */\r\n    keyPointIndex: number;\r\n\r\n    /**\r\n     * one of handlers of the curve when keyPoint's type is 'C'\r\n     */\r\n    controller1?: IController;\r\n\r\n    /**\r\n     * another handler of the curve when keyPoint's type is 'C'\r\n     */\r\n    controller2?: IController;\r\n\r\n    /**\r\n     * Straight line composed of aux-point(controller1) and origin-point\r\n     */\r\n    auxLine1?: any;\r\n\r\n    /**\r\n     * Straight line composed of aux-point(controller2) and origin-point\r\n     */\r\n    auxLine2?: any;\r\n\r\n    /**\r\n     * When current keyPoint is a handler of curve, attribute will be set\r\n     * 'handleA' as left handler\r\n     * 'handleB' as right handler\r\n     */\r\n    handleName?: string;\r\n\r\n    constructor({\r\n        type,\r\n        point,\r\n        pointType,\r\n        relationPoints,\r\n        keyPointIndex,\r\n        controller1,\r\n        controller2,\r\n        auxLine1,\r\n        auxLine2,\r\n        handleName\r\n    }: any = {}) {\r\n        this.type = type;\r\n        this.point = point;\r\n        this.pointType = pointType || CONST.POINT_TYPE.STRAIGHT;\r\n        this.relationPoints = relationPoints || [];\r\n        this.keyPointIndex = keyPointIndex;\r\n        this.controller1 = controller1;\r\n        this.controller2 = controller2;\r\n        this.auxLine1 = auxLine1;\r\n        this.auxLine2 = auxLine2;\r\n        this.handleName = handleName;\r\n    }\r\n}\r\n\r\nexport {\r\n    PenObject,\r\n    PenCircle,\r\n    PenLine,\r\n    KeyPoint\r\n}","import CONST from './constant'\r\nimport CURSOR_CONFIG from './cursorConfig'\r\nimport { KeyPoint, PenCircle, PenLine } from './classes'\r\nimport { IPenOptions, IPoint, IController } from './interface'\r\nimport { convertStr2Num, chunk, getAbsoluteCordinate } from './utils'\r\n\r\n/**\r\n * declare Pen Tool Class\r\n */\r\nclass Pen {\r\n    /**\r\n     * Whether the penTool's edit mode is opened. Default false.\r\n     */\r\n    penModeOn: boolean = false;\r\n\r\n    /**\r\n     * Store final path keyPoints data.\r\n     */\r\n    keyPointData: KeyPoint[] = [];\r\n\r\n    /**\r\n     * Store the real path keyPoints data, cause it's different from keyPointData when mousemove.\r\n     */\r\n    keyPointDataCache: KeyPoint[] = [];\r\n\r\n    /**\r\n     * Whether the path is closed\r\n     */\r\n    closeState: boolean = false;\r\n\r\n    /**\r\n     * Whether the real-path is closed. \r\n     * Fill the path containing area when cursor position and path start-point coincide during mousemoving (but not mouseup).\r\n     */\r\n    cacheCloseState: boolean = false;\r\n\r\n    /**\r\n     * The svg Path string\r\n     */\r\n    realPathStr: string;\r\n\r\n    /**\r\n     * Fabric.Path object\r\n     */\r\n    pathRealObject: object;\r\n\r\n    /**\r\n     * State of keyPoint.\r\n     * 'new' when mousedown which means new keyPoint, reset null when mouseup \r\n     */\r\n    keyPointState: string;\r\n\r\n    /**\r\n     * Index of current operation point in the keyPointData\r\n     */\r\n    currentKeyPointIndex: number;\r\n\r\n    /**\r\n     * Save the lastest mousedown positon\r\n     */\r\n    penMouseMoveFix: any;\r\n\r\n    /**\r\n     * Save part of the keyPoint information which is activated by mousedown \r\n     */\r\n    penMouseDownOrigin: any;\r\n\r\n    /**\r\n     * Whether the mousedown event is triggered\r\n     */\r\n    penMouseDown: boolean = false;\r\n\r\n    /**\r\n     * <canvas> element\r\n     */\r\n    canvas: HTMLCanvasElement;\r\n\r\n    /**\r\n     * canvas context('2d')\r\n     */\r\n    canvasCtx: CanvasRenderingContext2D;\r\n\r\n    /**\r\n     * Custom setting options\r\n     */\r\n    options: IPenOptions = {\r\n        circle: new PenCircle(),\r\n        line: new PenLine(),\r\n        pathColor: '#000',\r\n        pathFillColor: '#ebebeb',\r\n        isFillPath: false\r\n    }\r\n\r\n    /**\r\n     * Collection of objects drawn on canvas\r\n     */\r\n    objects: any[] = [];\r\n\r\n    /**\r\n     * Whether edit the keyPoint position\r\n     */\r\n    isEdit: boolean = false;\r\n\r\n    /**\r\n     * Save auxPoint or keyPoint when mousedown on the point\r\n     */\r\n    mousedownTarget?: any;\r\n\r\n    constructor(canvasId: string, options?: any, keyPointData?: KeyPoint[]) {\r\n        try {\r\n            if (!canvasId) {\r\n                console.error(\"PenTool must based a canvas, please confirm that the canvasId is passed.\")\r\n            } else {\r\n                this.canvas = <HTMLCanvasElement>document.getElementById(canvasId);\r\n                this.canvasCtx = this.canvas.getContext('2d');\r\n                this.options = {...{\r\n                    circle: new PenCircle(),\r\n                    line: new PenLine(),\r\n                    pathColor: '#000',          // default pathColor\r\n                    pathFillColor: '#ebebeb'    // default pathFillColor\r\n                }, ...options};\r\n\r\n                this.closeState = options ? options.closeState: false\r\n                this.keyPointData = keyPointData || [];\r\n                if (this.keyPointData.length > 0) {\r\n                    this.realPathStr = this._generatePathStr(this.keyPointData)\r\n                    this.drawPath({closeState: options.closeState})\r\n                }\r\n\r\n                // fire mouse event\r\n                this._mouseDown();\r\n                this._mouseMove();\r\n                this._mouseUp();\r\n                this._keydown();\r\n                this._mouseDblclick();\r\n            }\r\n        } catch (error) {\r\n            console.error(error.message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Open drawing mode\r\n     */\r\n    enablePen(): void {\r\n        this.penModeOn = true;\r\n        this.setCursor(CONST.CURSOR_TYPE.NORMAL);\r\n    }\r\n\r\n    /**\r\n     * Exit drawing mode\r\n     * The first call sets currentKeyPointIndex to null and set keyPoint editable\r\n     * The second call removes auxPoints and auxLines\r\n     */\r\n    exitPenMode() {\r\n        if (this.currentKeyPointIndex != null) {\r\n            this.currentKeyPointIndex = null;\r\n            this.isEdit = true;     // set editable\r\n            this.setCursor(CONST.CURSOR_TYPE.NORMAL);\r\n            this.refreshEditPath();\r\n        } else {\r\n            this.penModeOn = false;\r\n            if (this.pathRealObject) {\r\n                // remove auxPoint and auxLine\r\n                let auxPointAndLines = this.objects.filter((object: any) => {\r\n                    return object.penType === CONST.OBJECT_TYPE.PEN_AUX;\r\n                })\r\n                this.removeObjects(...auxPointAndLines);\r\n            }\r\n\r\n            this.setCursor(CONST.CURSOR_TYPE.DEFAULT);\r\n            // reset params\r\n            this.currentKeyPointIndex = null;\r\n            this.isEdit = false;\r\n        }\r\n        this.refreshRender();\r\n    }\r\n\r\n    /**\r\n     * Set cursor style\r\n     * @param type cursor type\r\n     */\r\n    setCursor(type: string): void {\r\n        if (type === CONST.CURSOR_TYPE.DEFAULT) {\r\n            this.canvas.style.cursor = 'default';\r\n        } else {\r\n            this.canvas.style.cursor = `url(${CURSOR_CONFIG[type]}), default`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * fire mousedown event\r\n     */\r\n    _mouseDown(): void {\r\n        this.canvas.addEventListener(\"mousedown\", event => {\r\n            if (this.penModeOn) {\r\n                this._penMouseDown(event);\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * fire mouseMove event\r\n     */\r\n    _mouseMove(): void {\r\n        this.canvas.addEventListener(\"mousemove\", event => {\r\n            if (this.penModeOn) {\r\n                if (this.penMouseDown) {\r\n                    this.setCursor(CONST.CURSOR_TYPE.MOVE);\r\n                }\r\n                this._penMouseMove(event);\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * fire mouseup event\r\n     */\r\n    _mouseUp(): void {\r\n        this.canvas.addEventListener(\"mouseup\", event => {\r\n            if (this.penModeOn) {\r\n                this.setCursor(CONST.CURSOR_TYPE.NORMAL);\r\n                this._penMouseUp(event);\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * fire path double click event\r\n     */\r\n    _mouseDblclick(): void {\r\n        this.canvas.addEventListener(\"dblclick\", event => {\r\n            if (this.penModeOn) {\r\n                let target = this._getMouseOverTarget(event);\r\n                if (target && target.penType === CONST.OBJECT_TYPE.PEN_AUX && target.handleName == null) {\r\n                    this.changeKeyPointType(target);\r\n                    this.refreshRender();\r\n                }\r\n            } else {\r\n                let point: IPoint = {\r\n                        x: event.offsetX,\r\n                        y: event.offsetY\r\n                    }, \r\n                    path: Path2D = new Path2D(this.realPathStr),\r\n                    isInPath: boolean = this.canvasCtx.isPointInPath(path, point.x, point.y);\r\n                if (isInPath) {\r\n                    this.setCursor(CONST.CURSOR_TYPE.NORMAL);\r\n                    this.generateEditablePath();\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * fire keydown event\r\n     * Support to press ESC to exit drawing mode\r\n     */\r\n    _keydown(): void {\r\n        // Set the tabIndex value of canvas so that canvas can get focus. Only in this way can canvas respond to keyboard events\r\n        this.canvas.setAttribute(\"tabIndex\", \"0\");\r\n        this.canvas.style.userSelect = \"none\";\r\n\r\n        this.canvas.addEventListener(\"keydown\", event => {\r\n            if (this.penModeOn) {\r\n                if (event.keyCode === 27) {\r\n                    this.exitPenMode();\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Implementation of MouseDown \r\n     * @param event \r\n     */\r\n    _penMouseDown(event: MouseEvent): void {\r\n        let target = this._getMouseOverTarget(event),\r\n            x = event.offsetX,\r\n            y = event.offsetY,\r\n            index: number;\r\n        this.penMouseDown = true;\r\n        this.mousedownTarget = target;\r\n        this.keyPointDataCache = null;\r\n        this.penMouseMoveFix = { x, y };\r\n\r\n        // update aux point fill color\r\n        this._matchObjectsByProrerty(\"penType\", CONST.OBJECT_TYPE.PEN_AUX, (object: any) => {\r\n            object.fill = \"#fff\";\r\n        })\r\n\r\n        // checks if the target is aux point\r\n        if (target !== null && target.penType === CONST.OBJECT_TYPE.PEN_AUX) {\r\n            index = target.keyPointIndex;\r\n            // fill the aux point \r\n            target.fill = target.stroke;\r\n\r\n            /**\r\n             * When the first and the last keyPoint coincide, the path is closed.\r\n             * Path is closed, set keyPoints editable.\r\n             */\r\n            if (this.keyPointData.length > 1 && this.currentKeyPointIndex === this.keyPointData.length - 1 && index === 0) {\r\n                this.closeState = true;\r\n            }\r\n\r\n            if (this.closeState || index !== this.keyPointData.length - 1) {\r\n                this.isEdit = true;\r\n            }\r\n            \r\n            this.currentKeyPointIndex = index;\r\n            this.setMousedownOrigin();\r\n            this.refreshEditPath();\r\n            return;\r\n        }\r\n\r\n        /**\r\n         * Normally, add keyPoint\r\n         */\r\n        if (this.keyPointData.length === 0 || this.currentKeyPointIndex === this.keyPointData.length - 1 && !this.closeState) {\r\n            let keyPoint: KeyPoint;\r\n            // first keyPoint, set type 'M'\r\n            if (this.keyPointData.length === 0) {\r\n                keyPoint = new KeyPoint({\r\n                    type: 'M',\r\n                    point: { x, y },\r\n                    pointType: CONST.POINT_TYPE.STRAIGHT,\r\n                    relationPoints: [x, y],\r\n                    keyPointIndex: this.keyPointData.length\r\n                })\r\n            } else {\r\n                let preKeyPoint = this.keyPointData[this.keyPointData.length - 1],\r\n                    preLeft = preKeyPoint.point.x,\r\n                    preTop = preKeyPoint.point.y;\r\n                if (preKeyPoint.pointType !== CONST.POINT_TYPE.STRAIGHT) {\r\n                    preLeft = preKeyPoint.controller2.x;\r\n                    preTop = preKeyPoint.controller2.y;\r\n                }\r\n                keyPoint = new KeyPoint({\r\n                    type: 'C',\r\n                    point: { x, y },\r\n                    pointType: CONST.POINT_TYPE.STRAIGHT,\r\n                    relationPoints: [preLeft, preTop, x, y, x, y],\r\n                    keyPointIndex: this.keyPointData.length\r\n                })\r\n            }\r\n\r\n            let circle = new PenCircle({\r\n                x: x,\r\n                y: y,\r\n                keyPointIndex: keyPoint.keyPointIndex,\r\n                fill: this.options.circle.fill,\r\n                stroke: this.options.circle.stroke\r\n            })\r\n            this.addCanvasObjects(circle);\r\n\r\n            this.keyPointData.push(keyPoint);\r\n            this.currentKeyPointIndex = this.keyPointData.length - 1;\r\n\r\n            this.refreshEditPath();\r\n            // add new keyPoint, set state\r\n            this.keyPointState = CONST.PATH_STATE.NEW;\r\n        } \r\n        \r\n        // clickoutside or 'ESC' keypress to exit penmode when editmode\r\n        else if (this.currentKeyPointIndex == null) {\r\n            this.exitPenMode();\r\n        } \r\n        \r\n        // first time: clickoutside or 'ESC' keypress set edit mode and reset currentKeyPointIndex\r\n        else if (this.keyPointData.length > 0 && (this.closeState || this.currentKeyPointIndex !== this.keyPointData.length - 1)) {\r\n            this.currentKeyPointIndex = null;\r\n            this.isEdit = true;\r\n        }\r\n        this.refreshRender();\r\n    }\r\n\r\n    /**\r\n     * Implementation of MouseMove\r\n     * @param event \r\n     */\r\n    _penMouseMove(event: MouseEvent): void {\r\n        let x = event.offsetX,\r\n            y = event.offsetY,\r\n            target = this._getMouseOverTarget(event);\r\n\r\n\r\n        if (!this.isEdit) {\r\n            // keep mousedown and mousemoving will draw a curve on canvas when current keyPoint is new\r\n            if (this.keyPointState === CONST.PATH_STATE.NEW) {\r\n                if (Math.abs(this.penMouseMoveFix.x - x) > 2 || Math.abs(this.penMouseMoveFix.y - y) > 2) {\r\n                    this.changeKeyPointPos(x, y, CONST.CONTROL_TYPE.RIGHT);\r\n                }\r\n            } else {\r\n                /**\r\n                 * when target is keyPoint\r\n                 * 1. target is not start or \r\n                 * 2. the path is closed or\r\n                 * 3. target is start but currentkeyPointIndex is not the last keyPoint's index(otherwise the path is closed).\r\n                 */\r\n                if (target != null && target.penType === CONST.OBJECT_TYPE.PEN_AUX && (target.keyPointIndex !== 0 || this.closeState || (target.keyPointIndex === 0 && this.currentKeyPointIndex !== this.keyPointData.length - 1))) {\r\n                    if (!this.penMouseDown) {\r\n                        this.setCursor(CONST.CURSOR_TYPE.MOVE);\r\n                    }\r\n                } else {\r\n                    this.setCursor(CONST.CURSOR_TYPE.NORMAL);\r\n                    if (this.currentKeyPointIndex === this.keyPointData.length - 1 && !this.closeState) {\r\n                        let keyPoint: KeyPoint,\r\n                            prev = this.keyPointData[this.currentKeyPointIndex],\r\n                            prevLeft: number,\r\n                            prevTop: number;\r\n                        if (this.keyPointDataCache == null) {\r\n                            this.keyPointDataCache = JSON.parse(JSON.stringify(this.keyPointData));\r\n                            this.keyPointDataCache.push(new KeyPoint());\r\n                        } else {\r\n                            this.cacheCloseState = false;\r\n                        }\r\n\r\n                        if (this.keyPointData[this.currentKeyPointIndex].type === \"M\") {\r\n                            prevLeft = prev.relationPoints[0];\r\n                            prevTop = prev.relationPoints[1];\r\n                        } else {\r\n                            prevLeft = prev.relationPoints[4];\r\n                            prevTop = prev.relationPoints[5];\r\n                        }\r\n\r\n                        if (prev.pointType !== CONST.POINT_TYPE.STRAIGHT) {\r\n                            prevLeft = prev.controller2.x;\r\n                            prevTop = prev.controller2.y;\r\n                        }\r\n                        keyPoint = new KeyPoint({\r\n                            type: \"C\",\r\n                            point: { x, y },\r\n                            pointType: CONST.POINT_TYPE.STRAIGHT,\r\n                            relationPoints: [prevLeft, prevTop, x, y, x, y],\r\n                            keyPointIndex: this.keyPointDataCache.length - 1\r\n                        })\r\n                        this.keyPointDataCache[this.keyPointDataCache.length - 1] = keyPoint;\r\n\r\n                        // path closed\r\n                        if (this.keyPointData.length > 1 && target !== null && target.penType === CONST.OBJECT_TYPE.PEN_AUX && target.keyPointIndex === 0) {\r\n                            this.cacheCloseState = true;\r\n                            this.setCursor(CONST.CURSOR_TYPE.CLOSE);\r\n                        } else {\r\n                            this.setCursor(CONST.CURSOR_TYPE.ADD);\r\n                        }\r\n\r\n                        this.refreshEditPath(true);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * keyPoint moving\r\n         * alt + handler keypoint moving: change path curve\r\n         */\r\n        else if (this.mousedownTarget != null && this.mousedownTarget.penType === CONST.OBJECT_TYPE.PEN_AUX && this.penMouseDown) {\r\n            let target = this.mousedownTarget;\r\n            target.x = x;\r\n            target.y = y;\r\n            if (target.handleName === CONST.CONTROL_TYPE.LEFT) {\r\n                if (event.altKey) {\r\n                    this.changeKeyPointType(target, CONST.POINT_TYPE.DISJOINTED);\r\n                } else {\r\n                    this.changeKeyPointType(target);\r\n                }\r\n                this.changeKeyPointPos(x, y, CONST.CONTROL_TYPE.LEFT);\r\n            } else if (target.handleName === CONST.CONTROL_TYPE.RIGHT) {\r\n                if (event.altKey) {\r\n                    this.changeKeyPointType(target, CONST.POINT_TYPE.DISJOINTED);\r\n                } else {\r\n                    this.changeKeyPointType(target);\r\n                }\r\n                this.changeKeyPointPos(x, y, CONST.CONTROL_TYPE.RIGHT);\r\n            } else {\r\n                this.changeKeyPointPos(x, y, CONST.CONTROL_TYPE.MAIN);\r\n            }\r\n        }\r\n        this.refreshRender();\r\n    }\r\n\r\n    /**\r\n     * Implementation of MouseUp\r\n     * @param event \r\n     */\r\n    _penMouseUp(event: MouseEvent): void {\r\n        this.penMouseDown = false;\r\n        if (this.currentKeyPointIndex === this.keyPointData.length - 1 && !this.closeState && this.penMouseMoveFix && event.offsetX === this.penMouseMoveFix.x && event.offsetY === this.penMouseMoveFix.y) {\r\n            this.isEdit = false;\r\n        }\r\n\r\n        // set main keyPoint fill\r\n        this._matchObjectsByProrerty(\"penType\", CONST.OBJECT_TYPE.PEN_AUX, (object: any) => {\r\n            if (object.keyPointIndex === this.currentKeyPointIndex && object.handleName == null) {\r\n                object.fill = object.stroke;\r\n            }\r\n        })\r\n\r\n        /** reset params */\r\n        this.keyPointState = null;\r\n        this.penMouseMoveFix = null;\r\n        this.penMouseDownOrigin = null;\r\n        this.refreshRender();\r\n    }\r\n\r\n    /**\r\n     * update keyPoint or handle point position\r\n     * @param x mouseOffsetX relative to canvas\r\n     * @param y mouseOffsetY relative to canvas\r\n     * @param type control point type\r\n     */\r\n    changeKeyPointPos(x: number, y: number, type: string = CONST.CONTROL_TYPE.MAIN): void {\r\n        let index = this.currentKeyPointIndex,\r\n            curKeyPoint: KeyPoint = this.keyPointData[index],\r\n            originPoint = curKeyPoint.point;\r\n\r\n        if ((type === CONST.CONTROL_TYPE.LEFT || type === CONST.CONTROL_TYPE.RIGHT) && curKeyPoint.pointType == CONST.POINT_TYPE.STRAIGHT) {\r\n            this.createPathCurveAux(curKeyPoint);\r\n        }\r\n\r\n        // keyPoint\r\n        if (type === CONST.CONTROL_TYPE.MAIN) {\r\n            let x1: number,\r\n                x2: number,\r\n                y1: number,\r\n                y2: number,\r\n                minulsX: number,\r\n                minulsY: number;\r\n\r\n            if (this.penMouseDownOrigin) {\r\n                if (this.penMouseDownOrigin.x) {\r\n                    minulsX = this.penMouseDownOrigin.x - x;\r\n                    minulsY = this.penMouseDownOrigin.y - y;\r\n                }\r\n\r\n                if (this.penMouseDownOrigin.x1) {\r\n                    x1 = this.penMouseDownOrigin.x1 - minulsX;\r\n                    y1 = this.penMouseDownOrigin.y1 - minulsY;\r\n                }\r\n\r\n                if (this.penMouseDownOrigin.x2) {\r\n                    x2 = this.penMouseDownOrigin.x2 - minulsX;\r\n                    y2 = this.penMouseDownOrigin.y2 - minulsY;\r\n                }\r\n\r\n                this.updatePenPathControll(curKeyPoint, { x, y, x1, y1, x2, y2 });\r\n            }\r\n\r\n            originPoint.x = x;\r\n            originPoint.y = y;\r\n\r\n            if (curKeyPoint.type === \"M\") {\r\n                curKeyPoint.relationPoints[0] = x;\r\n                curKeyPoint.relationPoints[1] = y;\r\n                if (index + 1 <= this.keyPointData.length - 1) {\r\n                    let nextItem = this.keyPointData[index + 1];\r\n                    if (curKeyPoint.pointType != CONST.POINT_TYPE.STRAIGHT) {\r\n                        nextItem.relationPoints[0] = x2;\r\n                        nextItem.relationPoints[1] = y2;\r\n                    } else {\r\n                        nextItem.relationPoints[0] = x;\r\n                        nextItem.relationPoints[1] = y;\r\n                    }\r\n                }\r\n\r\n                if (curKeyPoint.pointType != CONST.POINT_TYPE.STRAIGHT) {\r\n                    curKeyPoint.relationPoints[2] = x1;\r\n                    curKeyPoint.relationPoints[3] = y1;\r\n                }\r\n                curKeyPoint.point = { x, y };\r\n            } else {\r\n                if (curKeyPoint.pointType != CONST.POINT_TYPE.STRAIGHT) {\r\n                    curKeyPoint.relationPoints[2] = x1;\r\n                    curKeyPoint.relationPoints[3] = y1;\r\n                } else {\r\n                    curKeyPoint.relationPoints[2] = x;\r\n                    curKeyPoint.relationPoints[3] = y;\r\n                }\r\n\r\n                curKeyPoint.relationPoints[4] = x;\r\n                curKeyPoint.relationPoints[5] = y;\r\n\r\n                if (index + 1 <= this.keyPointData.length - 1) {\r\n                    let nextItem = this.keyPointData[index + 1];\r\n                    if (curKeyPoint.pointType != CONST.POINT_TYPE.STRAIGHT) {\r\n                        nextItem.relationPoints[0] = x2;\r\n                        nextItem.relationPoints[1] = y2;\r\n                    } else {\r\n                        nextItem.relationPoints[0] = x;\r\n                        nextItem.relationPoints[1] = y;\r\n                    }\r\n                }\r\n                curKeyPoint.point = { x, y };\r\n            }\r\n        } \r\n        // handle aux keyPoint\r\n        else if (type === CONST.CONTROL_TYPE.LEFT || type === CONST.CONTROL_TYPE.RIGHT) {\r\n            if (curKeyPoint.pointType == CONST.POINT_TYPE.STRAIGHT) {\r\n                curKeyPoint.pointType = CONST.POINT_TYPE.MIRRORED;\r\n            }\r\n            let x1: number,\r\n                y1: number,\r\n                x2: number,\r\n                y2: number;\r\n            let originX = curKeyPoint.relationPoints[4],\r\n                originY = curKeyPoint.relationPoints[5];\r\n\r\n            if (curKeyPoint.type == \"M\") {\r\n                originX = curKeyPoint.relationPoints[0];\r\n                originY = curKeyPoint.relationPoints[1];\r\n            }\r\n\r\n            if (curKeyPoint.pointType == CONST.POINT_TYPE.MIRRORED) {\r\n                if (type === CONST.CONTROL_TYPE.RIGHT) {\r\n                    x1 = originX * 2 - x;\r\n                    y1 = originY * 2 - y;\r\n                    x2 = x;\r\n                    y2 = y;\r\n                } else {\r\n                    x2 = originX * 2 - x;\r\n                    y2 = originY * 2 - y;\r\n                    x1 = x;\r\n                    y1 = y;\r\n                }\r\n\r\n                this.updatePenPathControll(curKeyPoint, { x: originX, y: originY, x1, y1, x2, y2 });\r\n\r\n                if (curKeyPoint.type === \"M\") {\r\n                    if (index + 1 <= this.keyPointData.length - 1) {\r\n                        let nextItem = this.keyPointData[index + 1];\r\n                        nextItem.relationPoints[0] = x2;\r\n                        nextItem.relationPoints[1] = y2;\r\n                    }\r\n\r\n                    if (curKeyPoint.pointType != CONST.POINT_TYPE.STRAIGHT) {\r\n                        curKeyPoint.relationPoints[2] = x1;\r\n                        curKeyPoint.relationPoints[3] = y1;\r\n                    }\r\n                } else {\r\n                    curKeyPoint.relationPoints[2] = x1;\r\n                    curKeyPoint.relationPoints[3] = y1;\r\n\r\n                    if (index + 1 <= this.keyPointData.length - 1) {\r\n                        var nextItem = this.keyPointData[index + 1];\r\n                        nextItem.relationPoints[0] = x2;\r\n                        nextItem.relationPoints[1] = y2;\r\n                    }\r\n                }\r\n            } else if (curKeyPoint.pointType == CONST.POINT_TYPE.DISJOINTED) {\r\n                if (type === CONST.CONTROL_TYPE.RIGHT) {\r\n                    x2 = x;\r\n                    y2 = y;\r\n                    this.updatePenPathControll(curKeyPoint, { x: originX, y: originY, x2, y2 }, CONST.CONTROL_TYPE.RIGHT);\r\n\r\n                    if (curKeyPoint.type === \"M\") {\r\n                        if (index + 1 <= this.keyPointData.length - 1) {\r\n                            let nextItem = this.keyPointData[index + 1];\r\n                            nextItem.relationPoints[0] = x2;\r\n                            nextItem.relationPoints[1] = y2;\r\n                        }\r\n                    } else {\r\n                        if (index + 1 <= this.keyPointData.length - 1) {\r\n                            let nextItem = this.keyPointData[index + 1];\r\n                            nextItem.relationPoints[0] = x2;\r\n                            nextItem.relationPoints[1] = y2;\r\n                        }\r\n\r\n                    }\r\n                } else {\r\n                    x1 = x;\r\n                    y1 = y;\r\n                    this.updatePenPathControll(curKeyPoint, { x: originX, y: originY, x1, y1 }, CONST.CONTROL_TYPE.LEFT);\r\n\r\n                    if (curKeyPoint.type === \"M\") {\r\n                        if (curKeyPoint.pointType != \"straight\") {\r\n                            curKeyPoint.relationPoints[2] = x1;\r\n                            curKeyPoint.relationPoints[3] = y1;\r\n                        }\r\n                    } else {\r\n                        curKeyPoint.relationPoints[2] = x1;\r\n                        curKeyPoint.relationPoints[3] = y1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.refreshEditPath();\r\n    }\r\n\r\n    /**\r\n     * creating aux control handlers for curve\r\n     * @param curKeyPoint the current operating keyPoint\r\n     */\r\n    createPathCurveAux(curKeyPoint: KeyPoint): void {\r\n        let originPoint = curKeyPoint.point,\r\n            x = originPoint.x,\r\n            y = originPoint.y;\r\n\r\n        let circle1 = new PenCircle({\r\n            x,\r\n            y,\r\n            handleName: CONST.CONTROL_TYPE.LEFT,\r\n            keyPointIndex: curKeyPoint.keyPointIndex,\r\n            fill: this.options.circle.fill,\r\n            stroke: this.options.circle.stroke,\r\n            lineWidth: this.options.circle.lineWidth\r\n        }),\r\n        circle2 = new PenCircle({\r\n            x,\r\n            y,\r\n            handleName: CONST.CONTROL_TYPE.RIGHT,\r\n            keyPointIndex: curKeyPoint.keyPointIndex,\r\n            fill: this.options.circle.fill,\r\n            stroke: this.options.circle.stroke,\r\n            lineWidth: this.options.circle.lineWidth\r\n        }),\r\n        line1 = new PenLine({\r\n            x1: x, y1: y, x2: x, y2: y,\r\n            stroke: this.options.line.stroke,\r\n            lineWidth: this.options.line.lineWidth\r\n        }),\r\n        line2 = new PenLine({\r\n            x1: x, y1: y, x2: x, y2: y,\r\n            stroke: this.options.line.stroke,\r\n            lineWidth: this.options.line.lineWidth\r\n        });\r\n        curKeyPoint.controller1 = circle1;\r\n        curKeyPoint.controller2 = circle2;\r\n        curKeyPoint.auxLine1 = line1;\r\n        curKeyPoint.auxLine2 = line2;\r\n\r\n        this.addCanvasObjects(circle1, circle2, line1, line2);\r\n    }\r\n\r\n    /**\r\n     * update the handlers of the curve\r\n     * @param item operating keyPoint\r\n     * @param position the key coordinates. {x, y, x1, y1, x2, y2}\r\n     * (x, y) is the main keyPoint's coordinates. (x1, y1) and (x2, y2) is the two controllers' coordinates.\r\n     * @param type Indicates which auxLine and controller to update\r\n     */\r\n    updatePenPathControll(item: KeyPoint, position: any, type?: string) {\r\n        let x = position.x,\r\n            y = position.y,\r\n            x1 = position.x1,\r\n            y1 = position.y1,\r\n            x2 = position.x2,\r\n            y2 = position.y2,\r\n            { controller1, controller2, auxLine1, auxLine2 } = { ...item };\r\n\r\n        if (type == null || type === CONST.CONTROL_TYPE.LEFT) {\r\n            if (controller1 != null) {\r\n                controller1.x = x1;\r\n                controller1.y = y1;\r\n            }\r\n            if (auxLine1 != null) {\r\n                auxLine1.x1 = x1;\r\n                auxLine1.y1 = y1;\r\n                auxLine1.x2 = x;\r\n                auxLine1.y2 = y;\r\n            }\r\n        }\r\n\r\n        if (type == null || type === CONST.CONTROL_TYPE.RIGHT) {\r\n            if (controller2 != null) {\r\n                controller2.x = x2;\r\n                controller2.y = y2;\r\n            }\r\n            if (auxLine2 != null) {\r\n                auxLine2.x1 = x2;\r\n                auxLine2.y1 = y2;\r\n                auxLine2.x2 = x;\r\n                auxLine2.y2 = y;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * save the coordinate informations when mousedown\r\n     * (x, y) is the main keyPoint's coordinate\r\n     * (x1, y1) and (x2, y2) is the controllers' coordinate\r\n     */\r\n    setMousedownOrigin() {\r\n        let curKeyPoint = this.keyPointData[this.currentKeyPointIndex],\r\n            controller1 = curKeyPoint.controller1,\r\n            controller2 = curKeyPoint.controller2,\r\n            originPoint = curKeyPoint.point,\r\n            origin: any = {};\r\n\r\n        if (controller1 != null) {\r\n            origin.x1 = controller1.x;\r\n            origin.y1 = controller1.y;\r\n        }\r\n\r\n        if (controller1 != null) {\r\n            origin.x2 = controller2.x;\r\n            origin.y2 = controller2.y;\r\n        }\r\n\r\n        if (originPoint != null) {\r\n            origin.x = originPoint.x;\r\n            origin.y = originPoint.y;\r\n        }\r\n        this.penMouseDownOrigin = origin;\r\n    };\r\n\r\n    /**\r\n     * update the pathObject when path is modified\r\n     * @param isCashed whether update path with the keyPointDataCache \r\n     */\r\n    refreshEditPath(isCashed: boolean = false): void {\r\n        let keyPointData = this.keyPointData,\r\n            closeState = this.closeState;\r\n        if (keyPointData.length === 0) return;\r\n\r\n        if (isCashed) {\r\n            keyPointData = this.keyPointDataCache;\r\n            closeState = this.cacheCloseState;\r\n        }\r\n        let pathStr: string = this._generatePathStr(keyPointData),\r\n            fillColor: string = null,\r\n            realPathStr = pathStr,\r\n            auxPathStr = pathStr;\r\n\r\n        if (closeState) {\r\n            fillColor = this.options.pathFillColor;\r\n            realPathStr += ' Z';\r\n            isCashed ? auxPathStr += ' Z' : '';\r\n        }\r\n        if (this.realPathStr != null && this.realPathStr === pathStr && isCashed) {\r\n            return;\r\n        } else {\r\n            this.realPathStr = realPathStr;\r\n\r\n            // remove and redraw path\r\n            let pathObjects = this.objects.filter(object => {\r\n                return object.type === CONST.OBJECT_TYPE.PATH;\r\n            })\r\n            this.removeObjects(...pathObjects);\r\n            this.pathRealObject = {\r\n                pathStr: this.realPathStr,\r\n                type: CONST.OBJECT_TYPE.PATH,\r\n                fill: fillColor || '#ebebeb',\r\n                closeState: closeState,\r\n                index: -Infinity    // path's z-index keep lowest\r\n            }\r\n            this.addCanvasObjects(this.pathRealObject);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * generate the pathStr according to keyPointData\r\n     * @param keyPointData \r\n     */\r\n    _generatePathStr(keyPointData: KeyPoint[]): string {\r\n        let pathStr = \"\";\r\n        keyPointData.forEach(keyPoint => {\r\n            let pathSection = \"\";\r\n            if (keyPoint.type === \"M\") {\r\n                let str = `M ${keyPoint.relationPoints[0]} ${keyPoint.relationPoints[1]} `;\r\n                pathSection += str;\r\n            } else if (keyPoint.type === \"C\") {\r\n                pathSection += \"C \";\r\n                keyPoint.relationPoints.forEach(value => {\r\n                    pathSection += value + \" \";\r\n                })\r\n            }\r\n            pathStr += pathSection;\r\n        })\r\n\r\n        if (this.closeState) {\r\n            let firstKeyPoint = keyPointData[0],\r\n                lastkeyPoint = keyPointData[keyPointData.length - 1];\r\n            pathStr += \"C \";\r\n            if (lastkeyPoint.pointType !== CONST.POINT_TYPE.STRAIGHT) {\r\n                pathStr += `${lastkeyPoint.controller2.x} ${lastkeyPoint.controller2.y} `;\r\n            } else {\r\n                pathStr += `${lastkeyPoint.relationPoints[4]} ${lastkeyPoint.relationPoints[5]} `;\r\n            }\r\n\r\n            if (firstKeyPoint.pointType !== CONST.POINT_TYPE.STRAIGHT) {\r\n                pathStr += `${firstKeyPoint.relationPoints[2]} ${firstKeyPoint.relationPoints[3]} `;\r\n            } else {\r\n                pathStr += `${firstKeyPoint.relationPoints[0]} ${firstKeyPoint.relationPoints[1]} `;\r\n            }\r\n\r\n            pathStr += `${firstKeyPoint.relationPoints[0]} ${firstKeyPoint.relationPoints[1]} `;\r\n        }\r\n        return pathStr;\r\n    }\r\n\r\n    /**\r\n     * refresh and redraw the canvas\r\n     */\r\n    refreshRender(): void {\r\n        this.canvasCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this._matchObjectsByProrerty(\"penType\", CONST.OBJECT_TYPE.PEN_AUX, (object: any) => {\r\n            if (object.type === CONST.OBJECT_TYPE.CIRCLE) {\r\n                this._bringToFront(object);\r\n            }\r\n        })\r\n        this.drawObjects(this.objects || []);\r\n    }\r\n\r\n    /**\r\n     * drawing object on canvas\r\n     * @param objects objects to be drawing\r\n     */\r\n    drawObjects(objects: Array<any>): void {\r\n        objects.forEach(object => {\r\n            switch (object.type) {\r\n                case CONST.OBJECT_TYPE.CIRCLE:\r\n                    this.drawCircle(object);\r\n                    break;\r\n                case CONST.OBJECT_TYPE.LINE:\r\n                    this.drawLine(object);\r\n                    break;\r\n                case CONST.OBJECT_TYPE.PATH:\r\n                    this.drawPath(object);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * draw circle on canvas\r\n     * @param options config of circle\r\n     */\r\n    drawCircle(options: any) {\r\n        this.canvasCtx.fillStyle = options.fill;\r\n        this.canvasCtx.strokeStyle = options.stroke;\r\n        this.canvasCtx.beginPath();\r\n        this.canvasCtx.arc(\r\n            options.x,\r\n            options.y,\r\n            options.radius,\r\n            0,\r\n            2 * Math.PI\r\n        )\r\n        this.canvasCtx.fill();\r\n        this.canvasCtx.stroke();\r\n    }\r\n\r\n    /**\r\n     * draw path on canvas\r\n     * @param options config of path\r\n     */\r\n    drawPath(options: any = {}) {\r\n        this.canvasCtx.fillStyle = this.options.pathFillColor;\r\n        this.canvasCtx.strokeStyle = this.options.pathColor;\r\n        if (this.penModeOn) this.canvasCtx.strokeStyle = '#000';\r\n\r\n        this.canvasCtx.beginPath();\r\n        let path = new Path2D(this.realPathStr);\r\n        this.canvasCtx.stroke(path);\r\n        \r\n        let isClosed = new RegExp('\\\\w*[zZ]{1}\\\\s*', 'g').test(this.realPathStr)\r\n        if (options.closeState || isClosed) {\r\n            /**\r\n             * keyPointDataCache is null indicate that the drawing is completed.\r\n             */\r\n            if (!this.keyPointDataCache && this.options.isFillPath) {\r\n                this.canvasCtx.fill(path);\r\n            } \r\n            \r\n            /**\r\n             * when drawing uncomplete, the cache path closed, then fill\r\n             */\r\n            else if (this.keyPointDataCache && this.keyPointData.length !== this.keyPointDataCache.length) {\r\n                this.canvasCtx.fill(path);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * draw straight line on canvas\r\n     * @param options config of line\r\n     */\r\n    drawLine(options: any) {\r\n        this.canvasCtx.fillStyle = options.fill;\r\n        this.canvasCtx.strokeStyle = options.stroke;\r\n        // this.canvasCtx.lineWidth = 5;\r\n        this.canvasCtx.beginPath();\r\n        this.canvasCtx.moveTo(options.x1, options.y1);\r\n        this.canvasCtx.lineTo(options.x2, options.y2);\r\n        this.canvasCtx.stroke();\r\n    }\r\n\r\n    /**\r\n     * Add objects to Pen instance for rendering\r\n     * @param objects objects for rendering\r\n     * @returns returns adding objects\r\n     */\r\n    addCanvasObjects(...objects: Array<any>): Array<any> {\r\n        objects.forEach(object => {\r\n            if (object.index == null) {\r\n                object.index = this.objects.length;\r\n            }\r\n            this.objects.push(object);\r\n        })\r\n        return objects;\r\n    }\r\n\r\n    /**\r\n     * remove objects from Pen instance\r\n     * @param objects objects to remove\r\n     */\r\n    removeObjects(...objects: Array<any>): void {\r\n        objects.forEach(object => {\r\n            this.removeSingleObject(object)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * match currect object and remove it from instance\r\n     * @param object object to remove\r\n     */\r\n    removeSingleObject(object: any): void {\r\n        for (let i = this.objects.length - 1; i >= 0; i--) {\r\n            const item = this.objects[i];\r\n            if (item === object) {\r\n                this.objects.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the mouseover target\r\n     * @param event \r\n     */\r\n    _getMouseOverTarget(event: MouseEvent): any {\r\n        let point: IPoint = {\r\n            x: event.offsetX,\r\n            y: event.offsetY\r\n        }, target: any = null;\r\n\r\n        // sort objects by index\r\n        this.objects.sort((a, b) => {\r\n            return a - b;\r\n        })\r\n\r\n        for (let i = this.objects.length - 1; i >= 0; i--) {\r\n            const object = this.objects[i];\r\n            if (this._containsPoint(point, object)) {\r\n                target = object;\r\n                break;\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * Checks if point is inside the object\r\n     * @param point target point, always mouse position\r\n     * @param object target object \r\n     */\r\n    _containsPoint(point: IPoint, object: any): boolean {\r\n        if (!object.type) return false;\r\n        if (object.type === CONST.OBJECT_TYPE.CIRCLE) {\r\n            let radius: number = object.radius,\r\n                x: number = object.x,\r\n                y: number = object.y;\r\n            return point.x <= x + radius && point.x >= x - radius\r\n                && point.y <= y + radius && point.y >= y - radius;\r\n\r\n        } else if (object.type === CONST.OBJECT_TYPE.LINE) {\r\n            // calculate the slope of line\r\n            let slope: number = (object.y1 - object.y2) / (object.x1 - object.x2),\r\n                slope2: number = (point.y - object.y1) / (point.x - object.x1);\r\n\r\n            // slope is equal and the point coordinate is included in the line area indicate collinearity\r\n            return slope === slope2 &&\r\n                (point.x >= object.x1 && point.x <= object.x2 && point.y >= object.y1 && point.y <= object.y2 ||\r\n                    point.x >= object.x2 && point.x <= object.x1 && point.y >= object.y2 && point.y <= object.y1\r\n                )\r\n        } else if (object.type === CONST.OBJECT_TYPE.PATH) {\r\n            let path = new Path2D(object.pathStr);\r\n            return this.canvasCtx.isPointInStroke(path, point.x, point.y);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Matches the object with the specified property name and value, and then performs the callback\r\n     * @param key property name\r\n     * @param value property value\r\n     * @param callback callback function\r\n     */\r\n    _matchObjectsByProrerty(key: string, value: string, callback: Function): void {\r\n        let objects: Array<any> = this.objects;\r\n        objects.forEach(object => {\r\n            // match object\r\n            if (object[key] === value) {\r\n                callback(object);\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Put the object at the end of the array to make canvas draw last\r\n     * so as to achieve the purpose of the object at the top after drawing\r\n     * @param object \r\n     */\r\n    _bringToFront(object: any) {\r\n        object.index = Infinity;    // Make sure the index is the largest\r\n\r\n        // resort objects and set index\r\n        this.objects.sort((a, b) => {\r\n            return a.index - b.index;\r\n        })\r\n        this.objects.forEach((item, index) => {\r\n            item.index = index;\r\n        })\r\n    }\r\n\r\n    /**\r\n     * change the keyPoint type when dblclick on the keyPoint\r\n     * when keyPoint is the straight line keyPoint, it will be a curve keyPoint after dblclick\r\n     * when keyPoint is the curve keyPoint, it will be a straight line keyPoint after dblclick\r\n     * @param target \r\n     * @param pointType the pointType attribute of current operating keyPoint\r\n     */\r\n    changeKeyPointType(target: KeyPoint, pointType?: string): void {\r\n        let index = target.keyPointIndex,\r\n            curPoint = this.keyPointData[index],\r\n            typelist = { ...CONST.POINT_TYPE };\r\n        if (!(pointType == null || (curPoint.pointType === CONST.POINT_TYPE.STRAIGHT && pointType in typelist) || (pointType === CONST.POINT_TYPE.STRAIGHT && curPoint.pointType in typelist))) {\r\n            curPoint.pointType = pointType;\r\n            return;\r\n        }\r\n\r\n        if (curPoint.controller1 == null) {\r\n            this.createPathCurveAux(curPoint);\r\n            curPoint.pointType = pointType || CONST.POINT_TYPE.MIRRORED;\r\n\r\n            let preItem: KeyPoint,      // previous keyPoint to target\r\n                nextItem: KeyPoint,     // next keyPoint to target\r\n                preX: number,           // previous keyPoint's coordinate\r\n                preY: number,           // previous keyPoint's coordinate\r\n                nextX: number,          // next keyPoint's coordinate\r\n                nextY: number,          // next keyPoint's coordinate\r\n                x: number,              // current keyPoint's coordinate\r\n                y: number,              // current keyPoint's coordinate\r\n                radian: number,         // the radian corresponding to the inclination angle of the line between two points\r\n                hypotenuse: number,     // the hypotenuse of a right triangle made up of two points\r\n                x1: number,\r\n                x2: number,\r\n                y1: number,\r\n                y2: number;\r\n            if (target.keyPointIndex === 0) {\r\n                preItem = this.keyPointData[this.keyPointData.length - 1];\r\n            } else {\r\n                preItem = this.keyPointData[target.keyPointIndex - 1];\r\n            }\r\n            if (target.keyPointIndex === this.keyPointData.length - 1) {\r\n                nextItem = this.keyPointData[0];\r\n            } else {\r\n                nextItem = this.keyPointData[target.keyPointIndex + 1];\r\n            }\r\n\r\n            preX = preItem.point.x,\r\n                preY = preItem.point.y,\r\n                nextX = nextItem.point.x,\r\n                nextY = nextItem.point.y,\r\n                x = curPoint.point.x,\r\n                y = curPoint.point.y;\r\n\r\n            radian = Math.atan2(nextY - preY, nextX - preX),\r\n                // The half of the hypotenuse of the right triangle formed by the coordinates of the previous and next keyPoint is used as the base of the offset when calculating the coordinates of the control point\r\n                hypotenuse = Math.sqrt(Math.pow(nextX - preX, 2) + Math.pow(nextY - preY, 2)) / 2;\r\n            x1 = Math.round(x - hypotenuse * Math.cos(radian)),\r\n                y1 = Math.round(y - hypotenuse * Math.sin(radian)),\r\n                x2 = Math.round(x + hypotenuse * Math.cos(radian)),\r\n                y2 = Math.round(y + hypotenuse * Math.sin(radian));\r\n            this.updatePenPathControll(curPoint, { x, y, x1, y1, x2, y2 });\r\n\r\n            if (index + 1 <= this.keyPointData.length - 1) {\r\n                let nextItem = this.keyPointData[index + 1];\r\n                nextItem.relationPoints[0] = x2;\r\n                nextItem.relationPoints[1] = y2;\r\n            }\r\n            curPoint.relationPoints[2] = x1;\r\n            curPoint.relationPoints[3] = y1;\r\n        } else {\r\n            this.removeObjects(curPoint.controller1, curPoint.controller2, curPoint.auxLine1, curPoint.auxLine2);\r\n            delete curPoint.controller1,\r\n                delete curPoint.controller2,\r\n                delete curPoint.auxLine1,\r\n                delete curPoint.auxLine2;\r\n\r\n            curPoint.pointType = CONST.POINT_TYPE.STRAIGHT;\r\n            let x = curPoint.point.x,\r\n                y = curPoint.point.y;\r\n            if (curPoint.pointType === \"M\") {\r\n                if (curPoint.relationPoints.length > 2) {\r\n                    curPoint.relationPoints.splice(-2, 2);\r\n                }\r\n            } else {\r\n                curPoint.relationPoints[2] = x;\r\n                curPoint.relationPoints[3] = y;\r\n            }\r\n            if (index + 1 <= this.keyPointData.length - 1) {\r\n                let nextItem = this.keyPointData[index + 1];\r\n                nextItem.relationPoints[0] = x;\r\n                nextItem.relationPoints[1] = y;\r\n            }\r\n        }\r\n        this.refreshEditPath();\r\n    }\r\n\r\n    /**\r\n     * generate the path with keyPoints and handlers\r\n     */\r\n    generateEditablePath() {\r\n        this.penModeOn = true;\r\n        // reset objects\r\n        this.objects = [];\r\n\r\n        // generate keyPoints and aux\r\n        this.generateAuxPointLine(this.keyPointData);\r\n\r\n        // generate pathstr\r\n        this.refreshEditPath();\r\n        this.refreshRender();\r\n    }\r\n\r\n    /**\r\n     * generate the aux keyPoints and handlers to render\r\n     * @param keyPointData collection of path's keyPoints\r\n     */\r\n    generateAuxPointLine(keyPointData: KeyPoint[] = []) {\r\n        if (keyPointData.length === 0) return;\r\n        keyPointData.forEach((keyPoint) => {\r\n            let x = keyPoint.point.x,\r\n                y = keyPoint.point.y,\r\n                circle = new PenCircle({\r\n                    x,\r\n                    y,\r\n                    keyPointIndex: keyPoint.keyPointIndex,\r\n                    fill: this.options.circle.fill,\r\n                    stroke: this.options.circle.stroke\r\n                });\r\n            this.addCanvasObjects(circle);  // add keyPoint\r\n\r\n            // when curve, add handlers \r\n            if (keyPoint.pointType !== CONST.POINT_TYPE.STRAIGHT) {\r\n                this.addCanvasObjects(keyPoint.auxLine1, keyPoint.auxLine2, keyPoint.controller1, keyPoint.controller2);\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nexport default Pen;\r\n\r\n"],"names":["CONST","PEN_AUX","CIRCLE","LINE","PATH","STRAIGHT","MIRRORED","DISJOINTED","LEFT","RIGHT","MAIN","NEW","ADD","NORMAL","MOVE","CLOSE","DEFAULT","cursorConfig","normal","add","close","move","PenObject","[object Object]","options","this","penType","stroke","fill","lineWidth","PenCircle","super","x","y","radius","keyPointIndex","handleName","type","PenLine","x1","y1","x2","y2","KeyPoint","point","pointType","relationPoints","controller1","controller2","auxLine1","auxLine2","canvasId","keyPointData","circle","line","pathColor","pathFillColor","isFillPath","canvas","document","getElementById","canvasCtx","getContext","closeState","length","realPathStr","_generatePathStr","drawPath","_mouseDown","_mouseMove","_mouseUp","_keydown","_mouseDblclick","console","error","message","penModeOn","setCursor","currentKeyPointIndex","isEdit","refreshEditPath","pathRealObject","auxPointAndLines","objects","filter","object","removeObjects","refreshRender","style","cursor","CURSOR_CONFIG","addEventListener","event","_penMouseDown","penMouseDown","_penMouseMove","_penMouseUp","target","_getMouseOverTarget","changeKeyPointType","offsetX","offsetY","path","Path2D","isPointInPath","generateEditablePath","setAttribute","userSelect","keyCode","exitPenMode","index","mousedownTarget","keyPointDataCache","penMouseMoveFix","_matchObjectsByProrerty","setMousedownOrigin","keyPoint","preKeyPoint","preLeft","preTop","addCanvasObjects","push","keyPointState","altKey","changeKeyPointPos","Math","abs","prevLeft","prevTop","prev","JSON","parse","stringify","cacheCloseState","penMouseDownOrigin","curKeyPoint","originPoint","createPathCurveAux","minulsX","minulsY","updatePenPathControll","nextItem","originX","originY","circle1","circle2","line1","line2","item","position","origin","isCashed","pathStr","fillColor","pathObjects","Infinity","forEach","pathSection","str","value","firstKeyPoint","lastkeyPoint","clearRect","width","height","_bringToFront","drawObjects","drawCircle","drawLine","fillStyle","strokeStyle","beginPath","arc","PI","isClosed","RegExp","test","moveTo","lineTo","removeSingleObject","i","splice","sort","a","b","_containsPoint","isPointInStroke","key","callback","curPoint","typelist","preItem","preX","preY","nextX","nextY","radian","hypotenuse","atan2","sqrt","pow","round","cos","sin","generateAuxPointLine"],"mappings":"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"}